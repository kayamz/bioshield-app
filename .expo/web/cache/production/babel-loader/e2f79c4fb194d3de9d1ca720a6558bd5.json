{"ast":null,"code":"import _regeneratorRuntime from\"@babel/runtime/regenerator\";import{PermissionStatus,createPermissionHook,EventEmitter,UnavailabilityError}from'expo-modules-core';import Platform from\"react-native-web/dist/exports/Platform\";import MediaLibrary from\"./ExponentMediaLibrary\";var eventEmitter=new EventEmitter(MediaLibrary);export{PermissionStatus};function arrayize(item){if(Array.isArray(item)){return item;}return item?[item]:[];}function getId(ref){if(typeof ref==='string'){return ref;}return ref?ref.id:undefined;}function checkAssetIds(assetIds){if(assetIds.some(function(id){return!id||typeof id!=='string';})){throw new Error('Asset ID must be a string!');}}function checkAlbumIds(albumIds){if(albumIds.some(function(id){return!id||typeof id!=='string';})){throw new Error('Album ID must be a string!');}}function checkMediaType(mediaType){if(Object.values(MediaType).indexOf(mediaType)===-1){throw new Error(\"Invalid mediaType: \"+mediaType);}}function checkSortBy(sortBy){if(Array.isArray(sortBy)){checkSortByKey(sortBy[0]);if(typeof sortBy[1]!=='boolean'){throw new Error('Invalid sortBy array argument. Second item must be a boolean!');}}else{checkSortByKey(sortBy);}}function checkSortByKey(sortBy){if(Object.values(SortBy).indexOf(sortBy)===-1){throw new Error(\"Invalid sortBy key: \"+sortBy);}}function dateToNumber(value){return value instanceof Date?value.getTime():value;}export var MediaType=MediaLibrary.MediaType;export var SortBy=MediaLibrary.SortBy;export function isAvailableAsync(){return _regeneratorRuntime.async(function isAvailableAsync$(_context){while(1){switch(_context.prev=_context.next){case 0:return _context.abrupt(\"return\",!!MediaLibrary&&'getAssetsAsync'in MediaLibrary);case 1:case\"end\":return _context.stop();}}},null,null,null,Promise);}export function requestPermissionsAsync(){var writeOnly,_args2=arguments;return _regeneratorRuntime.async(function requestPermissionsAsync$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:writeOnly=_args2.length>0&&_args2[0]!==undefined?_args2[0]:false;if(MediaLibrary.requestPermissionsAsync){_context2.next=3;break;}throw new UnavailabilityError('MediaLibrary','requestPermissionsAsync');case 3:_context2.next=5;return _regeneratorRuntime.awrap(MediaLibrary.requestPermissionsAsync(writeOnly));case 5:return _context2.abrupt(\"return\",_context2.sent);case 6:case\"end\":return _context2.stop();}}},null,null,null,Promise);}export function getPermissionsAsync(){var writeOnly,_args3=arguments;return _regeneratorRuntime.async(function getPermissionsAsync$(_context3){while(1){switch(_context3.prev=_context3.next){case 0:writeOnly=_args3.length>0&&_args3[0]!==undefined?_args3[0]:false;if(MediaLibrary.getPermissionsAsync){_context3.next=3;break;}throw new UnavailabilityError('MediaLibrary','getPermissionsAsync');case 3:_context3.next=5;return _regeneratorRuntime.awrap(MediaLibrary.getPermissionsAsync(writeOnly));case 5:return _context3.abrupt(\"return\",_context3.sent);case 6:case\"end\":return _context3.stop();}}},null,null,null,Promise);}export var usePermissions=createPermissionHook({getMethod:function getMethod(options){return getPermissionsAsync(options==null?void 0:options.writeOnly);},requestMethod:function requestMethod(options){return requestPermissionsAsync(options==null?void 0:options.writeOnly);}});export function presentPermissionsPickerAsync(){return _regeneratorRuntime.async(function presentPermissionsPickerAsync$(_context4){while(1){switch(_context4.prev=_context4.next){case 0:if(MediaLibrary.presentPermissionsPickerAsync){_context4.next=2;break;}throw new UnavailabilityError('MediaLibrary','presentPermissionsPickerAsync');case 2:_context4.next=4;return _regeneratorRuntime.awrap(MediaLibrary.presentPermissionsPickerAsync());case 4:return _context4.abrupt(\"return\",_context4.sent);case 5:case\"end\":return _context4.stop();}}},null,null,null,Promise);}export function createAssetAsync(localUri){var asset;return _regeneratorRuntime.async(function createAssetAsync$(_context5){while(1){switch(_context5.prev=_context5.next){case 0:if(MediaLibrary.createAssetAsync){_context5.next=2;break;}throw new UnavailabilityError('MediaLibrary','createAssetAsync');case 2:if(!(!localUri||typeof localUri!=='string')){_context5.next=4;break;}throw new Error('Invalid argument \"localUri\". It must be a string!');case 4:_context5.next=6;return _regeneratorRuntime.awrap(MediaLibrary.createAssetAsync(localUri));case 6:asset=_context5.sent;if(!Array.isArray(asset)){_context5.next=9;break;}return _context5.abrupt(\"return\",asset[0]);case 9:return _context5.abrupt(\"return\",asset);case 10:case\"end\":return _context5.stop();}}},null,null,null,Promise);}export function saveToLibraryAsync(localUri){return _regeneratorRuntime.async(function saveToLibraryAsync$(_context6){while(1){switch(_context6.prev=_context6.next){case 0:if(MediaLibrary.saveToLibraryAsync){_context6.next=2;break;}throw new UnavailabilityError('MediaLibrary','saveToLibraryAsync');case 2:_context6.next=4;return _regeneratorRuntime.awrap(MediaLibrary.saveToLibraryAsync(localUri));case 4:return _context6.abrupt(\"return\",_context6.sent);case 5:case\"end\":return _context6.stop();}}},null,null,null,Promise);}export function addAssetsToAlbumAsync(assets,album){var copy,assetIds,albumId,_args7=arguments;return _regeneratorRuntime.async(function addAssetsToAlbumAsync$(_context7){while(1){switch(_context7.prev=_context7.next){case 0:copy=_args7.length>2&&_args7[2]!==undefined?_args7[2]:true;if(MediaLibrary.addAssetsToAlbumAsync){_context7.next=3;break;}throw new UnavailabilityError('MediaLibrary','addAssetsToAlbumAsync');case 3:assetIds=arrayize(assets).map(getId);albumId=getId(album);checkAssetIds(assetIds);if(!(!albumId||typeof albumId!=='string')){_context7.next=8;break;}throw new Error('Invalid album ID. It must be a string!');case 8:if(!(Platform.OS==='ios')){_context7.next=12;break;}_context7.next=11;return _regeneratorRuntime.awrap(MediaLibrary.addAssetsToAlbumAsync(assetIds,albumId));case 11:return _context7.abrupt(\"return\",_context7.sent);case 12:_context7.next=14;return _regeneratorRuntime.awrap(MediaLibrary.addAssetsToAlbumAsync(assetIds,albumId,!!copy));case 14:return _context7.abrupt(\"return\",_context7.sent);case 15:case\"end\":return _context7.stop();}}},null,null,null,Promise);}export function removeAssetsFromAlbumAsync(assets,album){var assetIds,albumId;return _regeneratorRuntime.async(function removeAssetsFromAlbumAsync$(_context8){while(1){switch(_context8.prev=_context8.next){case 0:if(MediaLibrary.removeAssetsFromAlbumAsync){_context8.next=2;break;}throw new UnavailabilityError('MediaLibrary','removeAssetsFromAlbumAsync');case 2:assetIds=arrayize(assets).map(getId);albumId=getId(album);checkAssetIds(assetIds);_context8.next=7;return _regeneratorRuntime.awrap(MediaLibrary.removeAssetsFromAlbumAsync(assetIds,albumId));case 7:return _context8.abrupt(\"return\",_context8.sent);case 8:case\"end\":return _context8.stop();}}},null,null,null,Promise);}export function deleteAssetsAsync(assets){var assetIds;return _regeneratorRuntime.async(function deleteAssetsAsync$(_context9){while(1){switch(_context9.prev=_context9.next){case 0:if(MediaLibrary.deleteAssetsAsync){_context9.next=2;break;}throw new UnavailabilityError('MediaLibrary','deleteAssetsAsync');case 2:assetIds=arrayize(assets).map(getId);checkAssetIds(assetIds);_context9.next=6;return _regeneratorRuntime.awrap(MediaLibrary.deleteAssetsAsync(assetIds));case 6:return _context9.abrupt(\"return\",_context9.sent);case 7:case\"end\":return _context9.stop();}}},null,null,null,Promise);}export function getAssetInfoAsync(asset){var options,assetId,assetInfo,_args10=arguments;return _regeneratorRuntime.async(function getAssetInfoAsync$(_context10){while(1){switch(_context10.prev=_context10.next){case 0:options=_args10.length>1&&_args10[1]!==undefined?_args10[1]:{shouldDownloadFromNetwork:true};if(MediaLibrary.getAssetInfoAsync){_context10.next=3;break;}throw new UnavailabilityError('MediaLibrary','getAssetInfoAsync');case 3:assetId=getId(asset);checkAssetIds([assetId]);_context10.next=7;return _regeneratorRuntime.awrap(MediaLibrary.getAssetInfoAsync(assetId,options));case 7:assetInfo=_context10.sent;if(!Array.isArray(assetInfo)){_context10.next=10;break;}return _context10.abrupt(\"return\",assetInfo[0]);case 10:return _context10.abrupt(\"return\",assetInfo);case 11:case\"end\":return _context10.stop();}}},null,null,null,Promise);}export function getAlbumsAsync(){var _ref,_ref$includeSmartAlbu,includeSmartAlbums,_args11=arguments;return _regeneratorRuntime.async(function getAlbumsAsync$(_context11){while(1){switch(_context11.prev=_context11.next){case 0:_ref=_args11.length>0&&_args11[0]!==undefined?_args11[0]:{},_ref$includeSmartAlbu=_ref.includeSmartAlbums,includeSmartAlbums=_ref$includeSmartAlbu===void 0?false:_ref$includeSmartAlbu;if(MediaLibrary.getAlbumsAsync){_context11.next=3;break;}throw new UnavailabilityError('MediaLibrary','getAlbumsAsync');case 3:_context11.next=5;return _regeneratorRuntime.awrap(MediaLibrary.getAlbumsAsync({includeSmartAlbums:includeSmartAlbums}));case 5:return _context11.abrupt(\"return\",_context11.sent);case 6:case\"end\":return _context11.stop();}}},null,null,null,Promise);}export function getAlbumAsync(title){return _regeneratorRuntime.async(function getAlbumAsync$(_context12){while(1){switch(_context12.prev=_context12.next){case 0:if(MediaLibrary.getAlbumAsync){_context12.next=2;break;}throw new UnavailabilityError('MediaLibrary','getAlbumAsync');case 2:if(!(typeof title!=='string')){_context12.next=4;break;}throw new Error('Album title must be a string!');case 4:_context12.next=6;return _regeneratorRuntime.awrap(MediaLibrary.getAlbumAsync(title));case 6:return _context12.abrupt(\"return\",_context12.sent);case 7:case\"end\":return _context12.stop();}}},null,null,null,Promise);}export function createAlbumAsync(albumName,asset){var copyAsset,assetId,_args13=arguments;return _regeneratorRuntime.async(function createAlbumAsync$(_context13){while(1){switch(_context13.prev=_context13.next){case 0:copyAsset=_args13.length>2&&_args13[2]!==undefined?_args13[2]:true;if(MediaLibrary.createAlbumAsync){_context13.next=3;break;}throw new UnavailabilityError('MediaLibrary','createAlbumAsync');case 3:assetId=getId(asset);if(!(Platform.OS==='android'&&(typeof assetId!=='string'||assetId.length===0))){_context13.next=6;break;}throw new Error('MediaLibrary.createAlbumAsync must be called with an asset on Android.');case 6:if(!(!albumName||typeof albumName!=='string')){_context13.next=8;break;}throw new Error('Invalid argument \"albumName\". It must be a string!');case 8:if(!(assetId!=null&&typeof assetId!=='string')){_context13.next=10;break;}throw new Error('Asset ID must be a string!');case 10:if(!(Platform.OS==='ios')){_context13.next=14;break;}_context13.next=13;return _regeneratorRuntime.awrap(MediaLibrary.createAlbumAsync(albumName,assetId));case 13:return _context13.abrupt(\"return\",_context13.sent);case 14:_context13.next=16;return _regeneratorRuntime.awrap(MediaLibrary.createAlbumAsync(albumName,assetId,!!copyAsset));case 16:return _context13.abrupt(\"return\",_context13.sent);case 17:case\"end\":return _context13.stop();}}},null,null,null,Promise);}export function deleteAlbumsAsync(albums){var assetRemove,albumIds,_args14=arguments;return _regeneratorRuntime.async(function deleteAlbumsAsync$(_context14){while(1){switch(_context14.prev=_context14.next){case 0:assetRemove=_args14.length>1&&_args14[1]!==undefined?_args14[1]:false;if(MediaLibrary.deleteAlbumsAsync){_context14.next=3;break;}throw new UnavailabilityError('MediaLibrary','deleteAlbumsAsync');case 3:albumIds=arrayize(albums).map(getId);checkAlbumIds(albumIds);if(!(Platform.OS==='android')){_context14.next=9;break;}_context14.next=8;return _regeneratorRuntime.awrap(MediaLibrary.deleteAlbumsAsync(albumIds));case 8:return _context14.abrupt(\"return\",_context14.sent);case 9:_context14.next=11;return _regeneratorRuntime.awrap(MediaLibrary.deleteAlbumsAsync(albumIds,!!assetRemove));case 11:return _context14.abrupt(\"return\",_context14.sent);case 12:case\"end\":return _context14.stop();}}},null,null,null,Promise);}export function getAssetsAsync(){var assetsOptions,first,after,album,sortBy,mediaType,createdAfter,createdBefore,options,_args15=arguments;return _regeneratorRuntime.async(function getAssetsAsync$(_context15){while(1){switch(_context15.prev=_context15.next){case 0:assetsOptions=_args15.length>0&&_args15[0]!==undefined?_args15[0]:{};if(MediaLibrary.getAssetsAsync){_context15.next=3;break;}throw new UnavailabilityError('MediaLibrary','getAssetsAsync');case 3:first=assetsOptions.first,after=assetsOptions.after,album=assetsOptions.album,sortBy=assetsOptions.sortBy,mediaType=assetsOptions.mediaType,createdAfter=assetsOptions.createdAfter,createdBefore=assetsOptions.createdBefore;options={first:first==null?20:first,after:getId(after),album:getId(album),sortBy:arrayize(sortBy),mediaType:arrayize(mediaType||[MediaType.photo]),createdAfter:dateToNumber(createdAfter),createdBefore:dateToNumber(createdBefore)};if(!(first!=null&&typeof options.first!=='number')){_context15.next=7;break;}throw new Error('Option \"first\" must be a number!');case 7:if(!(after!=null&&typeof options.after!=='string')){_context15.next=9;break;}throw new Error('Option \"after\" must be a string!');case 9:if(!(album!=null&&typeof options.album!=='string')){_context15.next=11;break;}throw new Error('Option \"album\" must be a string!');case 11:if(!(after!=null&&Platform.OS==='android'&&isNaN(parseInt(getId(after),10)))){_context15.next=13;break;}throw new Error('Option \"after\" must be a valid ID!');case 13:if(!(first!=null&&first<0)){_context15.next=15;break;}throw new Error('Option \"first\" must be a positive integer!');case 15:options.sortBy.forEach(checkSortBy);options.mediaType.forEach(checkMediaType);_context15.next=19;return _regeneratorRuntime.awrap(MediaLibrary.getAssetsAsync(options));case 19:return _context15.abrupt(\"return\",_context15.sent);case 20:case\"end\":return _context15.stop();}}},null,null,null,Promise);}export function addListener(listener){return eventEmitter.addListener(MediaLibrary.CHANGE_LISTENER_NAME,listener);}export function removeSubscription(subscription){subscription.remove();}export function removeAllListeners(){eventEmitter.removeAllListeners(MediaLibrary.CHANGE_LISTENER_NAME);}export function getMomentsAsync(){return _regeneratorRuntime.async(function getMomentsAsync$(_context16){while(1){switch(_context16.prev=_context16.next){case 0:if(MediaLibrary.getMomentsAsync){_context16.next=2;break;}throw new UnavailabilityError('MediaLibrary','getMomentsAsync');case 2:_context16.next=4;return _regeneratorRuntime.awrap(MediaLibrary.getMomentsAsync());case 4:return _context16.abrupt(\"return\",_context16.sent);case 5:case\"end\":return _context16.stop();}}},null,null,null,Promise);}export function migrateAlbumIfNeededAsync(album){return _regeneratorRuntime.async(function migrateAlbumIfNeededAsync$(_context17){while(1){switch(_context17.prev=_context17.next){case 0:if(MediaLibrary.migrateAlbumIfNeededAsync){_context17.next=2;break;}return _context17.abrupt(\"return\");case 2:_context17.next=4;return _regeneratorRuntime.awrap(MediaLibrary.migrateAlbumIfNeededAsync(getId(album)));case 4:return _context17.abrupt(\"return\",_context17.sent);case 5:case\"end\":return _context17.stop();}}},null,null,null,Promise);}export function albumNeedsMigrationAsync(album){return _regeneratorRuntime.async(function albumNeedsMigrationAsync$(_context18){while(1){switch(_context18.prev=_context18.next){case 0:if(MediaLibrary.albumNeedsMigrationAsync){_context18.next=2;break;}return _context18.abrupt(\"return\",false);case 2:_context18.next=4;return _regeneratorRuntime.awrap(MediaLibrary.albumNeedsMigrationAsync(getId(album)));case 4:return _context18.abrupt(\"return\",_context18.sent);case 5:case\"end\":return _context18.stop();}}},null,null,null,Promise);}","map":{"version":3,"sources":["../src/MediaLibrary.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  PermissionResponse as EXPermissionResponse,\n  PermissionStatus,\n  PermissionExpiration,\n  PermissionHookOptions,\n  createPermissionHook,\n  EventEmitter,\n  Subscription,\n  UnavailabilityError,\n} from 'expo-modules-core';\nimport { Platform } from 'react-native';\n\nimport MediaLibrary from './ExponentMediaLibrary';\n\nconst eventEmitter = new EventEmitter(MediaLibrary);\n\n// @needsAudit\nexport type PermissionResponse = EXPermissionResponse & {\n  /**\n   * Indicates if your app has access to the whole or only part of the photo library. Possible values are:\n   * - `'all'` if the user granted your app access to the whole photo library\n   * - `'limited'` if the user granted your app access only to selected photos (only available on iOS 14.0+)\n   * - `'none'` if user denied or hasn't yet granted the permission\n   */\n  accessPrivileges?: 'all' | 'limited' | 'none';\n};\n\nexport type MediaTypeValue = 'audio' | 'photo' | 'video' | 'unknown';\nexport type SortByKey =\n  | 'default'\n  | 'mediaType'\n  | 'width'\n  | 'height'\n  | 'creationTime'\n  | 'modificationTime'\n  | 'duration';\nexport type SortByValue = [SortByKey, boolean] | SortByKey;\n\nexport type MediaTypeObject = {\n  audio: 'audio';\n  photo: 'photo';\n  video: 'video';\n  unknown: 'unknown';\n};\n\nexport type SortByObject = {\n  default: 'default';\n  mediaType: 'mediaType';\n  width: 'width';\n  height: 'height';\n  creationTime: 'creationTime';\n  modificationTime: 'modificationTime';\n  duration: 'duration';\n};\n\n// @needsAudit\nexport type Asset = {\n  /**\n   * Internal ID that represents an asset.\n   */\n  id: string;\n  /**\n   * Filename of the asset.\n   */\n  filename: string;\n  /**\n   * URI that points to the asset. `assets://*` (iOS), `file://*` (Android)\n   */\n  uri: string;\n  /**\n   * Media type.\n   */\n  mediaType: MediaTypeValue;\n  /**\n   * __iOS Only.__ An array of media subtypes.\n   */\n  mediaSubtypes?: MediaSubtype[];\n  /**\n   * Width of the image or video.\n   */\n  width: number;\n  /**\n   * Height of the image or video.\n   */\n  height: number;\n  /**\n   * File creation timestamp.\n   */\n  creationTime: number;\n  /**\n   * Last modification timestamp.\n   */\n  modificationTime: number;\n  /**\n   * Duration of the video or audio asset in seconds.\n   */\n  duration: number;\n  /**\n   * __Android Only.__ Album ID that the asset belongs to.\n   */\n  albumId?: string;\n};\n\n// @needsAudit\nexport type AssetInfo = Asset & {\n  /**\n   * Local URI for the asset.\n   */\n  localUri?: string;\n  /**\n   * GPS location if available.\n   */\n  location?: Location;\n  /**\n   * EXIF metadata associated with the image.\n   */\n  exif?: object;\n  /**\n   * __iOS Only.__ Whether the asset is marked as favorite.\n   */\n  isFavorite?: boolean;\n  /**\n   * __iOS Only.__ This field is available only if flag `shouldDownloadFromNetwork` is set to `false`.\n   * Whether the asset is stored on the network (iCloud on iOS)\n   */\n  isNetworkAsset?: boolean; //iOS only\n  /**\n   * __iOS Only.__ Display orientation of the image. Orientation is available only for assets whose\n   * `mediaType` is `MediaType.photo`. Value will range from 1 to 8, see [EXIF orientation specification](http://sylvana.net/jpegcrop/exif_orientation.html)\n   * for more details.\n   */\n  orientation?: number;\n};\n\n// @docsMissing\nexport type MediaSubtype =\n  | 'depthEffect'\n  | 'hdr'\n  | 'highFrameRate'\n  | 'livePhoto'\n  | 'panorama'\n  | 'screenshot'\n  | 'stream'\n  | 'timelapse';\n\n// @needsAudit\nexport type MediaLibraryAssetInfoQueryOptions = {\n  /**\n   * Whether allow the asset to be downloaded from network. Only available in iOS with iCloud assets.\n   * @default `true`\n   */\n  shouldDownloadFromNetwork?: boolean;\n};\n\n// @needsAudit\nexport type MediaLibraryAssetsChangeEvent = {\n  /**\n   * Whether the media library's changes could be described as \"incremental changes\".\n   * `true` indicates the changes are described by the `insertedAssets`, `deletedAssets` and\n   * `updatedAssets` values. `false` indicates that the scope of changes is too large and you\n   * should perform a full assets reload (eg. a user has changed access to individual assets in the\n   * media library).\n   */\n  hasIncrementalChanges: boolean;\n  /**\n   * Available only if `hasIncrementalChanges` is `true`.\n   * Array of [`Asset`](#asset)s that have been inserted to the library.\n   */\n  insertedAssets?: Asset[];\n  /**\n   * Available only if `hasIncrementalChanges` is `true`.\n   * Array of [`Asset`](#asset)s that have been deleted from the library.\n   */\n  deletedAssets?: Asset[];\n  /**\n   * Available only if `hasIncrementalChanges` is `true`.\n   * Array of [`Asset`](#asset)s that have been updated or completed downloading from network\n   * storage (iCloud on iOS).\n   */\n  updatedAssets?: Asset[];\n};\n\n// @docsMissing\nexport type Location = {\n  latitude: number;\n  longitude: number;\n};\n\n// @needsAudit @docsMissing\nexport type Album = {\n  id: string;\n  title: string;\n  /**\n   * Estimated number of assets in the album\n   */\n  assetCount: number;\n  /**\n   * __iOS Only.__ The type of the assets album.\n   */\n  type?: AlbumType;\n  /**\n   * __iOS Only.__ Apply only to albums whose type is `'moment'`. Earliest creation timestamp of all assets in the moment.\n   */\n  startTime: number;\n  /**\n   * __iOS Only.__ Apply only to albums whose type is `'moment'`. Latest creation timestamp of all assets in the moment.\n   */\n  endTime: number;\n  /**\n   * __iOS Only.__ Apply only to albums whose type is `'moment'`. Approximated location of all assets in the moment.\n   */\n  approximateLocation?: Location;\n  /**\n   *  __iOS Only.__ Apply only to albums whose type is `'moment'`. Names of locations grouped in the moment.\n   */\n  locationNames?: string[];\n};\n\n// @docsMissing\nexport type AlbumType = 'album' | 'moment' | 'smartAlbum';\n\n// @docsMissing\nexport type AlbumsOptions = {\n  includeSmartAlbums?: boolean;\n};\n\n// @needsAudit\nexport type AssetsOptions = {\n  /**\n   * The maximum number of items on a single page.\n   * @default `20`\n   */\n  first?: number;\n  /**\n   * Asset ID of the last item returned on the previous page.\n   */\n  after?: AssetRef;\n  /**\n   * [Album](#album) or its ID to get assets from specific album.\n   */\n  album?: AlbumRef;\n  /**\n   * An array of [`SortByValue`](#sortbyvalue)s or a single `SortByValue` value. By default, all\n   * keys are sorted in descending order, however you can also pass a pair `[key, ascending]` where\n   * the second item is a `boolean` value that means whether to use ascending order. Note that if\n   * the `SortBy.default` key is used, then `ascending` argument will not matter. Earlier items have\n   * higher priority when sorting out the results.\n   * If empty, this method will use the default sorting that is provided by the platform.\n   */\n  sortBy?: SortByValue[] | SortByValue;\n  /**\n   * An array of [MediaTypeValue](#expomedialibrarymediatypevalue)s or a single `MediaTypeValue`.\n   * @default `MediaType.photo`\n   */\n  mediaType?: MediaTypeValue[] | MediaTypeValue;\n  /**\n   * `Date` object or Unix timestamp in milliseconds limiting returned assets only to those that\n   * were created after this date.\n   */\n  createdAfter?: Date | number;\n  /**\n   * Similarly as `createdAfter`, but limits assets only to those that were created before specified\n   * date.\n   */\n  createdBefore?: Date | number;\n};\n\n// @needsAudit\nexport type PagedInfo<T> = {\n  /**\n   * A page of [`Asset`](#asset)s fetched by the query.\n   */\n  assets: T[];\n  /**\n   * ID of the last fetched asset. It should be passed as `after` option in order to get the\n   * next page.\n   */\n  endCursor: string;\n  /**\n   * Whether there are more assets to fetch.\n   */\n  hasNextPage: boolean;\n  /**\n   * Estimated total number of assets that match the query.\n   */\n  totalCount: number;\n};\n\n// @docsMissing\nexport type AssetRef = Asset | string;\n\n// @docsMissing\nexport type AlbumRef = Album | string;\n\nexport {\n  PermissionStatus,\n  PermissionExpiration,\n  EXPermissionResponse,\n  PermissionHookOptions,\n  Subscription,\n};\n\nfunction arrayize(item: any): any[] {\n  if (Array.isArray(item)) {\n    return item;\n  }\n  return item ? [item] : [];\n}\n\nfunction getId(ref: any): string | undefined {\n  if (typeof ref === 'string') {\n    return ref;\n  }\n  return ref ? ref.id : undefined;\n}\n\nfunction checkAssetIds(assetIds: any): void {\n  if (assetIds.some((id) => !id || typeof id !== 'string')) {\n    throw new Error('Asset ID must be a string!');\n  }\n}\n\nfunction checkAlbumIds(albumIds: any): void {\n  if (albumIds.some((id) => !id || typeof id !== 'string')) {\n    throw new Error('Album ID must be a string!');\n  }\n}\n\nfunction checkMediaType(mediaType: any): void {\n  if (Object.values(MediaType).indexOf(mediaType) === -1) {\n    throw new Error(`Invalid mediaType: ${mediaType}`);\n  }\n}\n\nfunction checkSortBy(sortBy: any): void {\n  if (Array.isArray(sortBy)) {\n    checkSortByKey(sortBy[0]);\n\n    if (typeof sortBy[1] !== 'boolean') {\n      throw new Error('Invalid sortBy array argument. Second item must be a boolean!');\n    }\n  } else {\n    checkSortByKey(sortBy);\n  }\n}\n\nfunction checkSortByKey(sortBy: any): void {\n  if (Object.values(SortBy).indexOf(sortBy) === -1) {\n    throw new Error(`Invalid sortBy key: ${sortBy}`);\n  }\n}\n\nfunction dateToNumber(value?: Date | number): number | undefined {\n  return value instanceof Date ? value.getTime() : value;\n}\n\n// @needsAudit\n/**\n * Possible media types.\n */\nexport const MediaType: MediaTypeObject = MediaLibrary.MediaType;\n\n// @needsAudit\n/**\n * Supported keys that can be used to sort `getAssetsAsync` results.\n */\nexport const SortBy: SortByObject = MediaLibrary.SortBy;\n\n// @needsAudit\n/**\n * Returns whether the Media Library API is enabled on the current device.\n * @return A promise which fulfils with a `boolean`, indicating whether the Media Library API is\n * available on the current device.\n */\nexport async function isAvailableAsync(): Promise<boolean> {\n  return !!MediaLibrary && 'getAssetsAsync' in MediaLibrary;\n}\n\n// @needsAudit @docsMissing\n/**\n * Asks the user to grant permissions for accessing media in user's media library.\n * @param writeOnly\n * @return A promise that fulfils with [`PermissionResponse`](#permissionresponse) object.\n */\nexport async function requestPermissionsAsync(\n  writeOnly: boolean = false\n): Promise<PermissionResponse> {\n  if (!MediaLibrary.requestPermissionsAsync) {\n    throw new UnavailabilityError('MediaLibrary', 'requestPermissionsAsync');\n  }\n  return await MediaLibrary.requestPermissionsAsync(writeOnly);\n}\n\n// @needsAudit @docsMissing\n/**\n * Checks user's permissions for accessing media library.\n * @param writeOnly\n * @return A promise that fulfils with [`PermissionResponse`](#permissionresponse) object.\n */\nexport async function getPermissionsAsync(writeOnly: boolean = false): Promise<PermissionResponse> {\n  if (!MediaLibrary.getPermissionsAsync) {\n    throw new UnavailabilityError('MediaLibrary', 'getPermissionsAsync');\n  }\n  return await MediaLibrary.getPermissionsAsync(writeOnly);\n}\n\n// @needsAudit\n/**\n * Check or request permissions to access the media library.\n * This uses both `requestPermissionsAsync` and `getPermissionsAsync` to interact with the permissions.\n *\n * @example\n * ```ts\n * const [status, requestPermission] = MediaLibrary.usePermissions();\n * ```\n */\nexport const usePermissions = createPermissionHook<PermissionResponse, { writeOnly?: boolean }>({\n  // TODO(cedric): permission requesters should have an options param or a different requester\n  getMethod: (options) => getPermissionsAsync(options?.writeOnly),\n  requestMethod: (options) => requestPermissionsAsync(options?.writeOnly),\n});\n\n// @needsAudit\n/**\n * __Available only on iOS >= 14.__ Allows the user to update the assets that your app has access to.\n * The system modal is only displayed if the user originally allowed only `limited` access to their\n * media library, otherwise this method is a no-op.\n * @return A promise that either rejects if the method is unavailable (meaning the device is not\n * running iOS >= 14), or resolves to `void`.\n * > __Note:__ This method doesn't inform you if the user changes which assets your app has access to.\n * For that information, you need to subscribe for updates to the user's media library using [addListener(listener)](#medialibraryaddlistenerlistener).\n * If `hasIncrementalChanges` is `false`, the user changed their permissions.\n */\nexport async function presentPermissionsPickerAsync(): Promise<void> {\n  if (!MediaLibrary.presentPermissionsPickerAsync) {\n    throw new UnavailabilityError('MediaLibrary', 'presentPermissionsPickerAsync');\n  }\n  return await MediaLibrary.presentPermissionsPickerAsync();\n}\n\n// @needsAudit\n/**\n * Creates an asset from existing file. The most common use case is to save a picture taken by [Camera](../camera).\n * This method requires `CAMERA_ROLL` permission.\n *\n * @example\n * ```js\n * const { uri } = await Camera.takePictureAsync();\n * const asset = await MediaLibrary.createAssetAsync(uri);\n * ```\n * @param localUri A URI to the image or video file. It must contain an extension. On Android it\n * must be a local path, so it must start with `file:///`\n * @return A promise which fulfils with an object representing an [`Asset`](#asset).\n */\nexport async function createAssetAsync(localUri: string): Promise<Asset> {\n  if (!MediaLibrary.createAssetAsync) {\n    throw new UnavailabilityError('MediaLibrary', 'createAssetAsync');\n  }\n\n  if (!localUri || typeof localUri !== 'string') {\n    throw new Error('Invalid argument \"localUri\". It must be a string!');\n  }\n  const asset = await MediaLibrary.createAssetAsync(localUri);\n\n  if (Array.isArray(asset)) {\n    // Android returns an array with asset, we need to pick the first item\n    return asset[0];\n  }\n  return asset;\n}\n\n// @needsAudit\n/**\n * Saves the file at given `localUri` to the user's media library. Unlike [`createAssetAsync()`](#medialibrarycreateassetasynclocaluri),\n * This method doesn't return created asset.\n * On __iOS 11+__, it's possible to use this method without asking for `CAMERA_ROLL` permission,\n * however then yours `Info.plist` should have `NSPhotoLibraryAddUsageDescription` key.\n * @param localUri A URI to the image or video file. It must contain an extension. On Android it\n * must be a local path, so it must start with `file:///`.\n */\nexport async function saveToLibraryAsync(localUri: string): Promise<void> {\n  if (!MediaLibrary.saveToLibraryAsync) {\n    throw new UnavailabilityError('MediaLibrary', 'saveToLibraryAsync');\n  }\n  return await MediaLibrary.saveToLibraryAsync(localUri);\n}\n\n// @needsAudit\n/**\n * Adds array of assets to the album.\n *\n * On Android, by default it copies assets from the current album to provided one, however it's also\n * possible to move them by passing `false` as `copyAssets` argument.In case they're copied you\n * should keep in mind that `getAssetsAsync` will return duplicated assets.\n * @param assets An array of [Asset](#asset) or their IDs.\n * @param album An [Album](#album) or its ID.\n * @param copy __Android only.__ Whether to copy assets to the new album instead of move them.\n * Defaults to `true`.\n * @return Returns promise which fulfils with `true` if the assets were successfully added to\n * the album.\n */\nexport async function addAssetsToAlbumAsync(\n  assets: AssetRef[] | AssetRef,\n  album: AlbumRef,\n  copy: boolean = true\n): Promise<boolean> {\n  if (!MediaLibrary.addAssetsToAlbumAsync) {\n    throw new UnavailabilityError('MediaLibrary', 'addAssetsToAlbumAsync');\n  }\n\n  const assetIds = arrayize(assets).map(getId);\n  const albumId = getId(album);\n\n  checkAssetIds(assetIds);\n\n  if (!albumId || typeof albumId !== 'string') {\n    throw new Error('Invalid album ID. It must be a string!');\n  }\n\n  if (Platform.OS === 'ios') {\n    return await MediaLibrary.addAssetsToAlbumAsync(assetIds, albumId);\n  }\n  return await MediaLibrary.addAssetsToAlbumAsync(assetIds, albumId, !!copy);\n}\n\n// @needsAudit\n/**\n * Removes given assets from album.\n *\n * On Android, album will be automatically deleted if there are no more assets inside.\n * @param assets An array of [Asset](#asset) or their IDs.\n * @param album An [Album](#album) or its ID.\n * @return Returns promise which fulfils with `true` if the assets were successfully removed from\n * the album.\n */\nexport async function removeAssetsFromAlbumAsync(\n  assets: AssetRef[] | AssetRef,\n  album: AlbumRef\n): Promise<boolean> {\n  if (!MediaLibrary.removeAssetsFromAlbumAsync) {\n    throw new UnavailabilityError('MediaLibrary', 'removeAssetsFromAlbumAsync');\n  }\n\n  const assetIds = arrayize(assets).map(getId);\n  const albumId = getId(album);\n\n  checkAssetIds(assetIds);\n  return await MediaLibrary.removeAssetsFromAlbumAsync(assetIds, albumId);\n}\n\n// @needsAudit\n/**\n * Deletes assets from the library. On iOS it deletes assets from all albums they belong to, while\n * on Android it keeps all copies of them (album is strictly connected to the asset). Also, there is\n * additional dialog on iOS that requires user to confirm this action.\n * @param assets An array of [Asset](#asset) or their IDs.\n * @return Returns promise which fulfils with `true` if the assets were successfully deleted.\n */\nexport async function deleteAssetsAsync(assets: AssetRef[] | AssetRef): Promise<boolean> {\n  if (!MediaLibrary.deleteAssetsAsync) {\n    throw new UnavailabilityError('MediaLibrary', 'deleteAssetsAsync');\n  }\n\n  const assetIds = arrayize(assets).map(getId);\n\n  checkAssetIds(assetIds);\n  return await MediaLibrary.deleteAssetsAsync(assetIds);\n}\n\n// @needsAudit\n/**\n * Provides more information about an asset, including GPS location, local URI and EXIF metadata.\n * @param asset An [Asset](#asset) or its ID.\n * @param options\n * @return [AssetInfo](#assetinfo) object, which is an `Asset` extended by an additional fields.\n */\nexport async function getAssetInfoAsync(\n  asset: AssetRef,\n  options: MediaLibraryAssetInfoQueryOptions = { shouldDownloadFromNetwork: true }\n): Promise<AssetInfo> {\n  if (!MediaLibrary.getAssetInfoAsync) {\n    throw new UnavailabilityError('MediaLibrary', 'getAssetInfoAsync');\n  }\n\n  const assetId = getId(asset);\n\n  checkAssetIds([assetId]);\n\n  const assetInfo = await MediaLibrary.getAssetInfoAsync(assetId, options);\n\n  if (Array.isArray(assetInfo)) {\n    // Android returns an array with asset info, we need to pick the first item\n    return assetInfo[0];\n  }\n  return assetInfo;\n}\n\n// @needsAudit\n/**\n * Queries for user-created albums in media gallery.\n * @return A promise which fulfils with an array of [`Album`](#asset)s. Depending on Android version,\n * root directory of your storage may be listed as album titled `\"0\"` or unlisted at all.\n */\nexport async function getAlbumsAsync({ includeSmartAlbums = false }: AlbumsOptions = {}): Promise<\n  Album[]\n> {\n  if (!MediaLibrary.getAlbumsAsync) {\n    throw new UnavailabilityError('MediaLibrary', 'getAlbumsAsync');\n  }\n  return await MediaLibrary.getAlbumsAsync({ includeSmartAlbums });\n}\n\n// @needsAudit\n/**\n * Queries for an album with a specific name.\n * @param title Name of the album to look for.\n * @return An object representing an [`Album`](#album), if album with given name exists, otherwise\n * returns `null`.\n */\nexport async function getAlbumAsync(title: string): Promise<Album> {\n  if (!MediaLibrary.getAlbumAsync) {\n    throw new UnavailabilityError('MediaLibrary', 'getAlbumAsync');\n  }\n  if (typeof title !== 'string') {\n    throw new Error('Album title must be a string!');\n  }\n  return await MediaLibrary.getAlbumAsync(title);\n}\n\n// @needsAudit\n/**\n * Creates an album with given name and initial asset. The asset parameter is required on Android,\n * since it's not possible to create empty album on this platform. On Android, by default it copies\n * given asset from the current album to the new one, however it's also possible to move it by\n * passing `false` as `copyAsset` argument.\n * In case it's copied you should keep in mind that `getAssetsAsync` will return duplicated asset.\n * @param albumName Name of the album to create.\n * @param asset An [Asset](#asset) or its ID (required on Android).\n * @param copyAsset __Android Only.__ Whether to copy asset to the new album instead of move it.\n * Defaults to `true`.\n * @return Newly created [`Album`](#album).\n */\nexport async function createAlbumAsync(\n  albumName: string,\n  asset?: AssetRef,\n  copyAsset: boolean = true\n): Promise<Album> {\n  if (!MediaLibrary.createAlbumAsync) {\n    throw new UnavailabilityError('MediaLibrary', 'createAlbumAsync');\n  }\n\n  const assetId = getId(asset);\n\n  if (Platform.OS === 'android' && (typeof assetId !== 'string' || assetId.length === 0)) {\n    // it's not possible to create empty album on Android, so initial asset must be provided\n    throw new Error('MediaLibrary.createAlbumAsync must be called with an asset on Android.');\n  }\n  if (!albumName || typeof albumName !== 'string') {\n    throw new Error('Invalid argument \"albumName\". It must be a string!');\n  }\n  if (assetId != null && typeof assetId !== 'string') {\n    throw new Error('Asset ID must be a string!');\n  }\n\n  if (Platform.OS === 'ios') {\n    return await MediaLibrary.createAlbumAsync(albumName, assetId);\n  }\n  return await MediaLibrary.createAlbumAsync(albumName, assetId, !!copyAsset);\n}\n\n// @needsAudit\n/**\n * Deletes given albums from the library. On Android by default it deletes assets belonging to given\n * albums from the library. On iOS it doesn't delete these assets, however it's possible to do by\n * passing `true` as `deleteAssets`.\n * @param albums An array of [`Album`](#asset)s or their IDs.\n * @param assetRemove __iOS Only.__ Whether to also delete assets belonging to given albums.\n * Defaults to `false`.\n * @return Returns a promise which fulfils with `true` if the albums were successfully deleted from\n * the library.\n */\nexport async function deleteAlbumsAsync(\n  albums: AlbumRef[] | AlbumRef,\n  assetRemove: boolean = false\n): Promise<boolean> {\n  if (!MediaLibrary.deleteAlbumsAsync) {\n    throw new UnavailabilityError('MediaLibrary', 'deleteAlbumsAsync');\n  }\n\n  const albumIds = arrayize(albums).map(getId);\n\n  checkAlbumIds(albumIds);\n  if (Platform.OS === 'android') {\n    return await MediaLibrary.deleteAlbumsAsync(albumIds);\n  }\n  return await MediaLibrary.deleteAlbumsAsync(albumIds, !!assetRemove);\n}\n\n// @needsAudit\n/**\n * Fetches a page of assets matching the provided criteria.\n * @param assetsOptions\n * @return A promise that fulfils with to [`PagedInfo`](#pagedinfo) object with array of [`Asset`](#asset)s.\n */\nexport async function getAssetsAsync(assetsOptions: AssetsOptions = {}): Promise<PagedInfo<Asset>> {\n  if (!MediaLibrary.getAssetsAsync) {\n    throw new UnavailabilityError('MediaLibrary', 'getAssetsAsync');\n  }\n\n  const { first, after, album, sortBy, mediaType, createdAfter, createdBefore } = assetsOptions;\n\n  const options = {\n    first: first == null ? 20 : first,\n    after: getId(after),\n    album: getId(album),\n    sortBy: arrayize(sortBy),\n    mediaType: arrayize(mediaType || [MediaType.photo]),\n    createdAfter: dateToNumber(createdAfter),\n    createdBefore: dateToNumber(createdBefore),\n  };\n\n  if (first != null && typeof options.first !== 'number') {\n    throw new Error('Option \"first\" must be a number!');\n  }\n  if (after != null && typeof options.after !== 'string') {\n    throw new Error('Option \"after\" must be a string!');\n  }\n  if (album != null && typeof options.album !== 'string') {\n    throw new Error('Option \"album\" must be a string!');\n  }\n\n  if (after != null && Platform.OS === 'android' && isNaN(parseInt(getId(after) as string, 10))) {\n    throw new Error('Option \"after\" must be a valid ID!');\n  }\n\n  if (first != null && first < 0) {\n    throw new Error('Option \"first\" must be a positive integer!');\n  }\n\n  options.sortBy.forEach(checkSortBy);\n  options.mediaType.forEach(checkMediaType);\n\n  return await MediaLibrary.getAssetsAsync(options);\n}\n\n// @needsAudit\n/**\n * Subscribes for updates in user's media library.\n * @param listener A callback that is fired when any assets have been inserted or deleted from the\n * library, or when the user changes which assets they're allowing access to. On Android it's\n * invoked with an empty object. On iOS it's invoked with [`MediaLibraryAssetsChangeEvent`](#medialibraryassetschangeevent)\n * object.\n * @return An [`Subscription`](#subscription) object that you can call `remove()` on when you would\n * like to unsubscribe the listener.\n */\nexport function addListener(\n  listener: (event: MediaLibraryAssetsChangeEvent) => void\n): Subscription {\n  return eventEmitter.addListener(MediaLibrary.CHANGE_LISTENER_NAME, listener);\n}\n\n// @docsMissing\nexport function removeSubscription(subscription: Subscription): void {\n  subscription.remove();\n}\n\n// @needsAudit\n/**\n * Removes all listeners.\n */\nexport function removeAllListeners(): void {\n  eventEmitter.removeAllListeners(MediaLibrary.CHANGE_LISTENER_NAME);\n}\n\n// @needsAudit\n/**\n * __iOS Only.__ Fetches a list of moments, which is a group of assets taken around the same place\n * and time.\n * @return An array of [albums](#album) whose type is `moment`.\n */\nexport async function getMomentsAsync() {\n  if (!MediaLibrary.getMomentsAsync) {\n    throw new UnavailabilityError('MediaLibrary', 'getMomentsAsync');\n  }\n\n  return await MediaLibrary.getMomentsAsync();\n}\n\n// @needsAudit\n/**\n * Moves album content to the special media directories on **Android R** or **above** if needed.\n * Those new locations are in line with the Android `scoped storage` - so your application won't\n * lose write permission to those directories in the future.\n *\n * This method does nothing if:\n * - app is running on **iOS**, **web** or **Android below R**\n * - app has **write permission** to the album folder\n *\n * The migration is possible when the album contains only compatible files types.\n * For instance, movies and pictures are compatible with each other, but music and pictures are not.\n * If automatic migration isn't possible, the function will be rejected.\n * In that case, you can use methods from the `expo-file-system` to migrate all your files manually.\n *\n * # Why do you need to migrate files?\n * __Android R__ introduced a lot of changes in the storage system. Now applications can't save\n * anything to the root directory. The only available locations are from the `MediaStore` API.\n * Unfortunately, the media library stored albums in folders for which, because of those changes,\n * the application doesn't have permissions anymore. However, it doesn't mean you need to migrate\n * all your albums. If your application doesn't add assets to albums, you don't have to migrate.\n * Everything will work as it used to. You can read more about scoped storage in [the Android documentation](https://developer.android.com/about/versions/11/privacy/storage).\n *\n * @param album An [Album](#album) or its ID.\n * @return A promise which fulfils to `void`.\n */\nexport async function migrateAlbumIfNeededAsync(album: AlbumRef): Promise<void> {\n  if (!MediaLibrary.migrateAlbumIfNeededAsync) {\n    return;\n  }\n\n  return await MediaLibrary.migrateAlbumIfNeededAsync(getId(album));\n}\n\n// @needsAudit\n/**\n * Checks if the album should be migrated to a different location. In other words, it checks if the\n * application has the write permission to the album folder. If not, it returns `true`, otherwise `false`.\n * > Note: For **Android below R**, **web** or **iOS**, this function always returns `false`.\n * @param album An [Album](#album) or its ID.\n * @return Returns a promise which fulfils with `true` if the album should be migrated.\n */\nexport async function albumNeedsMigrationAsync(album: AlbumRef): Promise<boolean> {\n  if (!MediaLibrary.albumNeedsMigrationAsync) {\n    return false;\n  }\n\n  return await MediaLibrary.albumNeedsMigrationAsync(getId(album));\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}